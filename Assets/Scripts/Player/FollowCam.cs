using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//1인칭, 3인칭 스위칭하는 기능 및 Offset값을 가지고 세부조정가능 
public class FollowCam : MonoBehaviour
{
    [Header("카메라 위치, 후방거리 ")]
    [SerializeField] GameObject LookTransform = null;
    [SerializeField] float RearBackDistance = 0f;

    [Header("카메라 위치 오프셋")]
    [SerializeField] Vector3 Offset = Vector3.zero;

    [Header("카메라 감도")]
    [SerializeField] float LookSensitivity = 1f;//기본 1

    [SerializeField] Transform Head;//Player Head Transform
    [SerializeField] Transform Body;//Player Body Tarnsform
    [SerializeField] Transform ShotTrs;

    float MouseXValue = 0f;
    float MouseYValue = 0f;
    float rotX;

    void Start()
    {
        //Offset = new Vector3(0f, 0f, -1f * RearBackDistance);

    }

    private void Update()
    {
        LookCamera();
        //Look();
    }
        

    private void LookCamera()
    {
        float MouseX = Input.GetAxisRaw("Mouse X");
        float MouseY = Input.GetAxisRaw("Mouse Y");

        MouseXValue = MouseXValue + MouseX;
        MouseYValue = MouseYValue + MouseY * (-1.0f);//반전
        //화면에서 회전을 반전시키기 위해 -1.0f을 곱함

        //화면의 각도 제한 
        MouseYValue = Mathf.Clamp(MouseYValue, -80f, 80f);

        //MouseXValue의 값을 Head.rotaion x값에 대입, 정면을 바라보는 기준으로 위,아래로  회전
        Head.localRotation = Quaternion.Euler(MouseYValue, 0f, 0f);
        //MouseXValue의 값을 Body.rotaion y값에 대입, 정면을 바라보는 기준으로 왼쪽,오른쪽으로 회전
        Body.localRotation = Quaternion.Euler(0f, MouseXValue, 0f);
        //
        ShotTrs.localRotation = Quaternion.Euler(MouseYValue, 0f, 0f);
        
        this.transform.rotation = Quaternion.Euler(MouseYValue * LookSensitivity, MouseXValue * LookSensitivity, 0f);
    }


    private void Look()
    {
        //Mouse X,Y: 매 프레임마다 마우스의 움직임 정도
        float mouseX = Input.GetAxis("Mouse X");
        float mouseY = Input.GetAxis("Mouse Y");

        // 플레이어 전체를 좌우 회전 (Y축)
        transform.Rotate(Vector3.up * mouseX);

        // Head만 상하 회전 (X축)
        rotX -= mouseY;
        rotX = Mathf.Clamp(rotX, -90f, 90f);
        transform.localRotation = Quaternion.Euler(rotX, 0f, 0f);
    }
    private void LateUpdate()
    {
        //transform.position = LookTransform.position + Offset;
        //transform.rotation = LookTransform.rotation;

        this.transform.position = LookTransform.transform.position + this.transform.rotation * Offset;
    }
}


